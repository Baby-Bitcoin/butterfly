const fs=require("fs"),path=require("path"),readline=require("readline");class butterfly{static INDEX_0=0;static INDEX_1=1;static INDEX_2=2;static INDEX_3=3;constructor(){if(butterfly.instance)return butterfly.instance;this.indexes=new Array(16).fill(null).map((()=>({}))),this.logDir=path.join(__dirname,"db/"),this.ensureLogDirExists(),this.reconstructFromLogs(),butterfly.instance=this}ensureLogDirExists(){fs.existsSync(this.logDir)||(fs.mkdirSync(this.logDir),console.log(`Created directory: ${this.logDir}`))}async reconstructFromLogs(){for(let e=0;e<16;e++){const t=path.join(this.logDir,`${e}.ndjson`);if(fs.existsSync(t)){console.log(`Reconstructing index ${e} from log file...`);const s={},n=fs.createReadStream(t,{encoding:"utf-8"}),i=readline.createInterface({input:n,crlfDelay:1/0});for await(const e of i)if(e.trim())try{const{operation:t,key:n,value:i}=JSON.parse(e);"set"===t?s[n]=i:"delete"===t&&(s[n]=null)}catch(t){console.error(`Failed to parse log line: ${e}`),console.error(t)}const r=[];for(const[t,n]of Object.entries(s))null!==n&&(this.setKey(e,t,n,!1),r.push(JSON.stringify({operation:"set",key:t,value:n})));fs.writeFileSync(t,r.join("\n")+"\n",{encoding:"utf-8"}),console.log(`Reconstruction and compaction of index ${e} completed, all 'delete' entries removed.`)}}}async writeLog(e,t,s,n=!0){if(n){const n=path.join(this.logDir,`${e}.ndjson`),i={operation:t,key:s.toString(),value:"set"===t?this.indexes[e][s]:void 0};fs.appendFileSync(n,JSON.stringify(i)+"\n",{encoding:"utf-8"})}}async getAllKeys(e){return Object.keys(this.indexes[e]||{})}async getNKeys(e,t,s,n="normal"){const i=await this.getAllKeys(e),r=s*t;return("reverse"===n?i.reverse():i).slice(r,r+t)}async getIndexContent(e){return this.indexes[e]}async searchKeys(e,t){const s=new RegExp(t);return this.getAllKeys(e).filter((e=>s.test(e)))}async setKey(e,t,s,n=!0){this.indexes[e][t]=s,this.writeLog(e,"set",t,n)}async getKey(e,t){return this.indexes[e][t]||null}async deleteKey(e,t,s=!0){this.indexes[e][t]?(console.log(`Deleting key: ${t} from index: ${e}`),delete this.indexes[e][t],await this.writeLog(e,"delete",t,s),console.log(`Key ${t} deleted successfully from index ${e}`)):console.error(`Conflict 409: Key ${t} does not exist in index ${e}`)}async getNewID(e){const t=butterfly[e],s=this.getAllKeys(t);let n=0;for(const e of s){const s=await this.getKey(t,e);s&&"number"==typeof s.id&&(n=Math.max(n,s.id))}return n+1}}module.exports={butterfly:butterfly,db:new butterfly};