const fs=require("fs"),path=require("path"),readline=require("readline");class InMemoryDB{static instances={};static ADDRESSES_DB=0;static POSTS_DB=1;static VOTES_DB=2;static COMMENTS_DB=3;constructor(){if(InMemoryDB.instance)return InMemoryDB.instance;this.indexes=new Array(16).fill(null).map((()=>({}))),this.logDir=path.join(__dirname,"db/"),this.ensureLogDirExists(),this.reconstructFromLogs(),InMemoryDB.instance=this}ensureLogDirExists(){fs.existsSync(this.logDir)||(fs.mkdirSync(this.logDir),console.log(`Created directory: ${this.logDir}`))}async reconstructFromLogs(){for(let e=0;e<16;e++){const t=path.join(this.logDir,`${e}.ndjson`);if(fs.existsSync(t)){console.log(`Reconstructing index ${e} from log file...`);const n={},s=fs.createReadStream(t,{encoding:"utf-8"}),i=readline.createInterface({input:s,crlfDelay:1/0});for await(const e of i)if(e.trim())try{const{operation:t,key:s,value:i}=JSON.parse(e);"set"===t?n[s]=i:"delete"===t&&(n[s]=null)}catch(t){console.error(`Failed to parse log line: ${e}`),console.error(t)}const o=[];for(const[t,s]of Object.entries(n))null!==s&&(this.setKey(e,t,s,!1),o.push(JSON.stringify({operation:"set",key:t,value:s})));fs.writeFileSync(t,o.join("\n")+"\n",{encoding:"utf-8"}),console.log(`Reconstruction and compaction of index ${e} completed, all 'delete' entries removed.`)}}}async writeLog(e,t,n,s=!0){if(s){const s=path.join(this.logDir,`${e}.ndjson`),i={operation:t,key:n.toString(),value:"set"===t?this.indexes[e][n]:void 0};fs.appendFileSync(s,JSON.stringify(i)+"\n",{encoding:"utf-8"})}}convertKeyType(e,t){return e===InMemoryDB.ADDRESSES_DB?String(t):Number(t)}async getAllKeys(e){return Object.keys(this.indexes[e]||{})}async getNKeys(e,t,n,s="normal"){const i=await this.getAllKeys(e),o=n*t;return("reverse"===s?i.reverse():i).slice(o,o+t)}async getIndexContent(e){return this.indexes[e]}async searchKeys(e,t){const n=new RegExp(t);return this.getAllKeys(e).filter((e=>n.test(e)))}async setKey(e,t,n,s=!0){t=this.convertKeyType(e,t);const i=this.indexes[e][t];void 0!==i&&(Array.isArray(i)&&Array.isArray(n)?n=Array.from(new Set([...i,...n])):"object"==typeof i&&"object"==typeof n&&(n={...i,...n})),this.indexes[e][t]=n,this.writeLog(e,"set",t,s)}async getKey(e,t){return t=this.convertKeyType(e,t),this.indexes[e][t]||null}async deleteKey(e,t,n=!0){t=this.convertKeyType(e,t),this.indexes[e][t]?(console.log(`Deleting key: ${t} from index: ${e}`),delete this.indexes[e][t],await this.writeLog(e,"delete",t,n),console.log(`Key ${t} deleted successfully from index ${e}`)):console.error(`Conflict 409: Key ${t} does not exist in index ${e}`)}async getNewID(){const e=InMemoryDB.POSTS_DB,t=await this.getAllKeys(e);let n=0;for(const s of t){const t=await this.getKey(e,s);t&&"number"==typeof t.id&&(n=Math.max(n,t.id))}return n+1}}module.exports={InMemoryDB:InMemoryDB,dbConnection:new InMemoryDB};